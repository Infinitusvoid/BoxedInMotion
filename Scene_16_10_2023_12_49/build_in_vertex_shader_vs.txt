#version 330 core
layout (location = 0) in vec3 aPos;

// Define the instance data struct
struct Instance_data
{
	mat4 model;
	vec4 color;
};

layout(location = 3) in Instance_data instanceData;

out vec4 Color;
out vec3 FragWorldPos; // World space position
out vec3 FragObjectPos; // Object space position

uniform mat4 projection;
uniform mat4 view;

uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;

// ========================== 

float dot2( in vec2 v ) { return dot(v,v); }
float dot2( in vec3 v ) { return dot(v,v); }
float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }

float sdSphere( vec3 p, float s )
{
  return length(p)-s;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float sdBoxFrame( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// ==========================

// 
// Define a function to generate a random number based on an input integer
float generateRandomNumber(int inputInt) {
    // Cast the input integer to uint to address type mismatch
    uint seed = uint(inputInt);

    // Define the hash function
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);

    // Normalize and return the result
    return float(seed) / 4294967296.0; // Normalize to [0, 1]
}

//

// Function to compute the offset for the sphere
vec3 computeSphereOffset(float latitude, float longitude, float radius)
{
    float theta = 2.0 * 3.14159265359 * latitude;
    float phi = 2.0 * 3.14159265359 * longitude;

    float x = radius * sin(theta) * cos(phi);
    float y = radius * cos(theta);
    float z = radius * sin(theta) * sin(phi);

    return vec3(x, y, z);
}




void main()
{
	int id = gl_InstanceID;
	FragObjectPos = aPos; // Store the object space position
	FragWorldPos = vec3(instanceData.model * vec4(aPos, 1.0)); // Calculate world space position
	Color = instanceData.color;

	float u = float(id % 1000) * 0.001;
	float v = float(id / 1000) * 0.001;
	
    			
    			
    //412963	779127	504726	995824	966801
    //529204	904411	160869	431461	594141				


    float value_rnd_0 = generateRandomNumber(id + 131257);
    float value_rnd_1 = generateRandomNumber(id + 992987);
    float value_rnd_2 = generateRandomNumber(id + 910208);
    float value_rnd_3 = generateRandomNumber(id + 929639);
    float value_rnd_4 = generateRandomNumber(id + 408968);
    float value_rnd_5 = generateRandomNumber(id + 882850);
    float value_rnd_6 = generateRandomNumber(id + 149966);
    float value_rnd_7 = generateRandomNumber(id + 685375);
    float value_rnd_8 = generateRandomNumber(id + 395867);
    float value_rnd_9 = generateRandomNumber(id + 692275);


    float x = mod( value_rnd_0 * 10000 + time * (value_rnd_3 - 0.5) * 2.0 * 100, 2000);
    float y = mod( value_rnd_1 * 10000 + time * (value_rnd_4 - 0.5) * 2.0 * 100, 2000);
    float z = mod( value_rnd_2 * 10000 + time * (value_rnd_5 - 0.5) * 2.0 * 100, 2000);
    
    vec3 offset = vec3(x, y, z);

    //float d = sdBox(offset - vec3(0.0, 500 + 400 * sin(time) * 0.1+ 100 * (sin(x * 0.01 + time) + cos(y * 0.01 + time)), 0.0), vec3(10000, 100, 10000));
    

    float d = sdBox(offset - vec3(0.0, 0.0, 0.0), vec3(10000, 100, 10000));
    


	//offset = computeSphereOffset(u, v, 1000.0 + 500 * sin(time * 100+ value_0));
    
   
   //float scale = 1.0 / ( clamp(d, 0.0, 1.0) + 0.001);
   float scale = 1.0;

   


   float value = 0.0;
   if(d < 0)
   {
    value = 1.0;
    scale = 2.4;
   }
   else
   {
    scale = 0.2;
    value = 0.2;
   }
    

	Color = vec4(value * value_rnd_9, value * value_rnd_7, value * value_rnd_4, 1.0);


	gl_Position = projection * view * instanceData.model * vec4(aPos * scale + offset, 1.0);
}
