#version 330 core
layout (location = 0) in vec3 aPos;

// Define the instance data struct
struct Instance_data
{
	mat4 model;
	vec4 color;
};

layout(location = 3) in Instance_data instanceData;

out vec4 Color;
out vec3 FragWorldPos; // World space position
out vec3 FragObjectPos; // Object space position

uniform mat4 projection;
uniform mat4 view;

uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;

// ========================== 

float dot2( in vec2 v ) { return dot(v,v); }
float dot2( in vec3 v ) { return dot(v,v); }
float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }

float sdSphere( vec3 p, float s )
{
  return length(p)-s;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}


float opUnion( float d1, float d2 ) { return min(d1,d2); }
float opSubtraction( float d1, float d2 ) { return max(-d1,d2); }
float opIntersection( float d1, float d2 ) { return max(d1,d2); }


float opSmoothUnion( float d1, float d2, float k ) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); }

float opSmoothSubtraction( float d1, float d2, float k ) {
    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
    return mix( d2, -d1, h ) + k*h*(1.0-h); }

float opSmoothIntersection( float d1, float d2, float k ) {
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) + k*h*(1.0-h); }

// ==========================

// 
// Define a function to generate a random number based on an input integer
float generateRandomNumber(int inputInt) {
    // Cast the input integer to uint to address type mismatch
    uint seed = uint(inputInt);

    // Define the hash function
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);

    // Normalize and return the result
    return float(seed) / 4294967296.0; // Normalize to [0, 1]
}

//

// Function to compute the offset for the sphere
vec3 computeSphereOffset(float latitude, float longitude, float radius)
{
    float theta = 2.0 * 3.14159265359 * latitude;
    float phi = 2.0 * 3.14159265359 * longitude;

    float x = radius * sin(theta) * cos(phi);
    float y = radius * cos(theta);
    float z = radius * sin(theta) * sin(phi);

    return vec3(x, y, z);
}




void main()
{
	int id = gl_InstanceID;
	FragObjectPos = aPos; // Store the object space position
	FragWorldPos = vec3(instanceData.model * vec4(aPos, 1.0)); // Calculate world space position
	Color = instanceData.color;

	float u = float(id % 1000) * 0.001;
	float v = float(id / 1000) * 0.001;
	
    			
    			
    //412963	779127	504726	995824	966801
    //529204	904411	160869	431461	594141				


    float value_rnd_0 = generateRandomNumber(id + 131257);
    float value_rnd_1 = generateRandomNumber(id + 992987);
    float value_rnd_2 = generateRandomNumber(id + 910208);
    float value_rnd_3 = generateRandomNumber(id + 929639);
    float value_rnd_4 = generateRandomNumber(id + 408968);
    float value_rnd_5 = generateRandomNumber(id + 882850);
    float value_rnd_6 = generateRandomNumber(id + 149966);
    float value_rnd_7 = generateRandomNumber(id + 685375);
    float value_rnd_8 = generateRandomNumber(id + 395867);
    float value_rnd_9 = generateRandomNumber(id + 692275);


    float x = mod( value_rnd_0 * 10000 + time * (value_rnd_3 - 0.5) * 2.0 * 10, 1000);
    float y = mod( value_rnd_1 * 10000 + time * (value_rnd_4 - 0.5) * 2.0 * 10, 1000);
    float z = mod( value_rnd_2 * 10000 + time * (value_rnd_5 - 0.5) * 2.0 * 10, 1000);
    
    vec3 offset = vec3(x, y, z);

    //float d = sdBox(offset - vec3(0.0, 500 + 400 * sin(time) * 0.1+ 100 * (sin(x * 0.01 + time) + cos(y * 0.01 + time)), 0.0), vec3(10000, 100, 10000));
    
    
    vec3 q = offset * 4.0;

    q += vec3(0, - time * 240, 0);

    vec3 spacing = vec3(1000, 1000, 1000);

    float id_q = (ceil(q.x / spacing.x) + ceil(q.y / spacing.y) + ceil(q.z / spacing.z));
    

    q = q  - spacing * round(q / spacing);

    // float d_0 = sdBox(q - vec3(1000, 0.0, 1000), vec3(1000, 100, 1000));
    // float d_1 = sdBox(q - vec3(1000, 0.0, 1000), vec3(900, 200, 900));

    // float d_2 = sdBox(q - vec3(1000, 1000, 0.0), vec3(1000, 1000, 100));
    // float d_3 = sdBox(q - vec3(1000, 1000, 0.0), vec3(900, 900, 100));

    float u0 = 200;

    float d_0 = sdBox(q - vec3(500, 0.0, 500), vec3(1000, 100, 1000));
    float d_1 = sdBox(q - vec3(500, 0.0, 500), vec3(u0, 200, u0));

    float d_2 = sdBox(q - vec3(500, 500, 0.0), vec3(1000, 1000, 100));
    float d_3 = sdBox(q - vec3(500, 500, 0.0), vec3(u0, u0, 100));

    float d = 0.0;
    d = opSubtraction(d_1, d_0);
    d = opUnion(d, opSubtraction(d_3, d_2));


	//offset = computeSphereOffset(u, v, 1000.0 + 500 * sin(time * 100+ value_0));
    
   
   //float scale = 1.0 / ( clamp(d, 0.0, 1.0) + 0.001);
   float scale = 1.0;

   
   offset *= 10;

   float value = 0.0;
   if(d < 0)
   {
    value = 1.4;
    scale = 4.4;
    
    float v0 =  generateRandomNumber(int(id_q));
    scale = v0 * 10.0;
   }
   else
   {
    scale = 0.02;
    value = 0.2;
   }
    

	Color = vec4(value * value_rnd_9, value * value_rnd_7, value * value_rnd_4, 1.0);


	gl_Position = projection * view * instanceData.model * vec4(aPos * scale + offset, 1.0);
}
