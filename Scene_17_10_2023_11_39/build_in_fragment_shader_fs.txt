#version 330 core
layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 BrightColor;
in vec4 Color;
in vec3 FragWorldPos; // Input world space position
in vec3 FragObjectPos; // Input object space position


uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;



// Defines constants ======================

#define PI 3.14159265359
#define TAO ( PI * 2.0 )
#define PI_2 ( PI * 2.0 )

#define SQRT_OF_2 1.4142135623730951

// ========================================


// Additional inputs
flat in int instanceID;

flat in vec3 frag_msg_tile_off;
flat in int frag_msg_tile_type; 
flat in vec3 frag_msg_tile_index; 
flat in vec2 frag_msg_uv;
flat in int frag_msg_ixz;

flat in float frag_msg_tile_rnd_0;
flat in float frag_msg_tile_rnd_1;
flat in float frag_msg_tile_rnd_2;
flat in float frag_msg_tile_rnd_3;
flat in float frag_msg_tile_rnd_4;
// 

// Utils

// cosine based palette, 4 vec3 params
vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

// 


void main()
{
    vec3 color = vec3(0.0, 0.0, 0.0);
    float factor_color_vertex = 1.0;

    //color.r = 1.0 + sin(FragWorldPos.x * 10);
    //color.g = 1.0 + sin(FragWorldPos.y * 10);
    //color.b = 1.0 + sin(FragWorldPos.y * 10);
    
    //color.r = sin(frag_msg_tile_off.x * 10 * PI_2);
    //color.g = sin(frag_msg_tile_off.y * 100 * PI_2);
    //color.b = sin(frag_msg_tile_off.z * 10 * PI_2);
    
    //if(frag_msg_tile_type == 4)
    //{
    //    color = vec3(1.0, 1.0, 1.0);
    //}

    //color.b = min(max(sin(frag_msg_tile_index.x * 4.0) * 100, 0), 2);
    //color.g = min(max(sin(frag_msg_tile_index.y * 4.0) * 100, 0), 2);
    //color.g = min(max(sin(frag_msg_tile_index.z * 4.0) * 100, 0), 2);
    
    
    if(frag_msg_tile_type == 1)
    {
        //float value = sin(frag_msg_tile_off.x * PI_2 * ceil(frag_msg_tile_rnd_0 * 20) + sin(frag_msg_tile_off.z * PI_2 * 2 + time));
        
        float value = 0.0;

        value = sin(frag_msg_tile_off.x * PI_2 * 10) * 2.0;
        value = max(value, sin(frag_msg_tile_off.z * PI_2 * 10) * 2.0);

        value = frag_msg_tile_off.y * 124.0;
        if(value > 1.0)
        {
            float q_0 = mod(frag_msg_tile_off.x + sin(frag_msg_tile_off.z * PI_2 * 2), 0.1) * 10;
            
            color.r = q_0;
            color.g = 1.0;
            color.b = 1.0;
        }
        else
        {
            color.g = 0.2;
        }
       

        //color = vec3(0.0, frag_msg_tile_off.y * 24 * value, 0.0) * 10;
        //color.r = frag_msg_tile_rnd_0;
        //color.g = sin(frag_msg_uv.x * PI_2 * 10); //sin(frag_msg_uv.x * PI_2 * 10) * frag_msg_tile_rnd_0;
        //color.b = frag_msg_tile_rnd_2; //sin(frag_msg_uv.y * PI_2 * 10) * frag_msg_tile_rnd_1;
    

        factor_color_vertex = 0.0;
    }
    
    
    
    
    vec4 result = Color * factor_color_vertex + vec4(color, 1.0);

    FragColor = result * 1.0;
    float factor_brightnes = dot(vec3(result), vec3(0.2126, 0.7152, 0.0722));
    if(factor_brightnes > 1.0) // transhold usually set at 1.0
    {
        BrightColor = vec4(result.x * 10.0, result.y * 10.0, result.z * 10.0, 1.0);
    }
    else
    {
        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
    
}
