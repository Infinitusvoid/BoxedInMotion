#version 330 core
layout (location = 0) in vec3 aPos;

// Define the instance data struct
struct Instance_data
{
	mat4 model;
	vec4 color;
};

layout(location = 3) in Instance_data instanceData;

out vec4 Color;
out vec3 FragWorldPos; // World space position
out vec3 FragObjectPos; // Object space position

uniform mat4 projection;
uniform mat4 view;

uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;

// #################################


// Defines ================================

#define PI 3.14159265359
#define TAO PI * 2.0

// ========================================

// ====================
// Utils functionality

// cosine based palette, 4 vec3 params
vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

// Define a function to generate a random number based on an input integer
float generateRandomNumber(int inputInt)
{
    // Cast the input integer to uint to address type mismatch
    uint seed = uint(inputInt);

    // Define the hash function
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);

    // Normalize and return the result
    return float(seed) / 4294967296.0; // Normalize to [0, 1]
}

vec3 calculate_index(vec3 p, vec3 spacing)
{
    return  vec3(round(p.x / spacing.x), round(p.y / spacing.y), round(p.z / spacing.z));
}

// ====================



// Function to compute the offset for the sphere
vec3 computeSphereOffset(float latitude, float longitude, float radius)
{
    float theta = 2.0 * 3.14159265359 * latitude;
    float phi = 2.0 * 3.14159265359 * longitude;

    float x = radius * sin(theta) * cos(phi);
    float y = radius * cos(theta);
    float z = radius * sin(theta) * sin(phi);

    return vec3(x, y, z);
}

vec3 parametricCube(float u, float v, float sideLength) {
    // Map u and v values to the range [0, 1]
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);

    // Calculate the cube's position in 3D space
    float x = mix(-sideLength, sideLength, u); // Varies from -sideLength to sideLength
    float y = mix(-sideLength, sideLength, v); // Varies from -sideLength to sideLength
    float z = sideLength; // Fixed z value to create a surface

    return vec3(x, y, z);
}

vec3 parametricCubeSide(float u, float v, float sideLength, int face) {
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);

    float halfLength = sideLength / 2.0;

    // Initialize position
    vec3 position = vec3(0.0);

    if (face == 0) {  // Front face
        position = vec3(u * sideLength - halfLength, v * sideLength - halfLength, halfLength);
    } else if (face == 1) {  // Back face
        position = vec3(halfLength - u * sideLength, v * sideLength - halfLength, -halfLength);
    } else if (face == 2) {  // Top face
        position = vec3(u * sideLength - halfLength, halfLength, v * sideLength - halfLength);
    } else if (face == 3) {  // Bottom face
        position = vec3(u * sideLength - halfLength, -halfLength, v * sideLength - halfLength);
    } else if (face == 4) {  // Right face
        position = vec3(halfLength, u * sideLength - halfLength, v * sideLength - halfLength);
    } else if (face == 5) {  // Left face
        position = vec3(-halfLength, halfLength - u * sideLength, v * sideLength - halfLength);
    }

    return position;
}

vec3 parametricCubeFull(float u, float v, float sideLength)
{
    vec3 position = vec3(0.0);
    if(u < ((1.0 / 3.0) * 1.0) )
    {
        if(v < 0.5)
        {
            position = parametricCubeSide(u * 3.0, v * 2.0, 1000.0, 0);
        }
        else
        {
            position = parametricCubeSide(u * 3.0, (v-0.5) * 2.0, 1000.0, 1);
        }
    }
    else if(u < ((1.0 / 3.0) * 2.0) )
    {
        if(v < 0.5)
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 1.0)) * 3.0 , v * 2.0, 1000.0, 2);
        }
        else
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 1.0)) * 3.0, (v-0.5) * 2.0, 1000.0, 3);
        }
    }
    else
    {
         if(v < 0.5)
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 2.0)) * 3.0, v * 2.0, 1000.0, 4);
        }
        else
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 2.0)) * 3.0, (v-0.5) * 2.0, 1000.0, 5);
        }
    }

    return position;
}

vec3 calculate_instance_position(vec3 offset)
{
    return (instanceData.model * vec4(aPos + offset, 1.0)).xyz;
}

float waveform_0_f1(float x)
{
    return max(min(x*(5.0), 1.0),0.0);
}

float waveform_0_f2(float x)
{
    return max(min(-(x*5.0)+1.0 + 4.0, 1.0), 0.0);    
}

float waveform_0_f3(float x)
{
    
    return waveform_0_f1(x) * waveform_0_f2(x);
}

float waveform_0_f4(float x, float t)
{
    return pow(waveform_0_f3(x),  2 + (0.34 + 0.76 * sin(t + x*10000)))  * (0.99 + 0.01 * sin(x * 100 + t));
}

void main()
{
	int id = gl_InstanceID;
	FragObjectPos = aPos; // Store the object space position
	FragWorldPos = vec3(instanceData.model * vec4(aPos, 1.0)); // Calculate world space position
	Color = instanceData.color;


    // u, v
    // float u = float(id % 1000) * 0.001;
	// float v = float(id / 1000) * 0.001;
	


    float particles_speed_factor = 0.01;
    float u_speed = (generateRandomNumber(id * 10033) - 0.5) * particles_speed_factor;
    float v_speed = (generateRandomNumber(id * 12334) - 0.5) * particles_speed_factor;
   
    // looping space for instances
    
    // uv randomized
    float u = generateRandomNumber(id * 10023);
    float v = generateRandomNumber(id * 21823);

    // uv update position
    u += u_speed * time;
    v += v_speed * time;
    
    u = fract(u);
    v = fract(v);

    float off_v = 0.0;
    float d_center = length(vec3(u, 0, v) - vec3(0.5, 0, 0.0));
    d_center = pow(d_center, 0.5);

    off_v = d_center;

    off_v += 0.001 * sin(u * PI * 2.0 * 10 + time * 0.0);
    off_v += -0.0002 * sin(u * PI * 2.0 * 2 + time * 0.0);
    
    float x_global = u + time * 0.01;
    float y_global = v + time * 0.01;

    vec3 spacing = vec3(0.04, 0.04, 0.04);
    vec3 tile_coord = vec3(x_global / 0.04, off_v / 0.04, y_global / 0.04);
    //vec3 tile_local_coord = vec3(mod(x_global, spacing.x), mod(off_v, spacing.y), mod(y_global, spacing.z)) * (1 / 0.04);
    vec3 tile_local_coord = fract((vec3(x_global, off_v, y_global) + (spacing * 0.5)) * (1 / 0.04));
    vec3 tile_index = vec3(round(tile_coord.x), round(tile_coord.y), round(tile_coord.z)); // calculate_index(vec3(x_global, off_v, y_global), spacing);
    int ixz = int(tile_index.x + tile_index.z);
    int ixz2 = int(tile_index.x * tile_index.z) % 999999;
   float tile_rnd_1 = generateRandomNumber( ixz + 176043);
   float tile_rnd_2 = generateRandomNumber( ixz + 538819);
   float tile_rnd_3 = generateRandomNumber( ixz + 558013);
   float tile_rnd_wave = generateRandomNumber( ixz + 762774);
   float tile_rnd_building = generateRandomNumber( ixz2 + 45447);
  
   //vec3 tile_rnd_color = vec3(tile_rnd_1, tile_rnd_2, tile_rnd_3);
   vec3 tile_rnd_color = vec3(tile_rnd_1, tile_rnd_2 , tile_rnd_3);

   

   float tile_x = tile_index.x;
   float tile_y = tile_index.z;
   float tile_off_v = 0.001 * sin(tile_coord.x * PI * 2.0 * 4 * tile_rnd_3 + time * 0.0) + 0.0002 * cos(tile_coord.y * PI * 2.0 * 4 * tile_rnd_wave + time * 0.0);

   if(tile_rnd_building > 0.5)
   {
    tile_off_v *= 0;
    tile_off_v += min(waveform_0_f4(tile_local_coord.z, time * 0.01), waveform_0_f4(tile_local_coord.x, time * 0.001)) * 0.01;
   }

   

   off_v += tile_off_v;

   

   float tile_rnd_4 = generateRandomNumber(id * 762774);

   vec3 offset = vec3(0.0, 0.0, 0.0);
   offset = vec3(u, off_v, v) * 10000;

   
   vec3 cube_position = calculate_instance_position(offset);
   vec3 v_cam = cube_position - camera_position;
   float d = length(v_cam);
    
   float factor_color_amplification = 1.0;
   if(d < 10)
   {
        factor_color_amplification *= 10;
   }

   
   
   float size_amplification = 1.0;
   if(d < 1)
   {
     size_amplification = 1.0 + (100.0 - (d+1.0)) * 0.1 ;
     //offset += vec3(0.0, -100.0, 0.0);
   }
    

    vec3 color = vec3(1.0, 1.0, 1.0);
    color *= tile_rnd_color;
    




    color *= factor_color_amplification;

	//Color = vec4(0.2 * v_cam.x, 0.4 * v_cam.y, 0.2 * v_cam.z, 1.0) + vec4(0.0, 0.0, 0.0, 1.0) * factor_color_amplification;
    Color = vec4(color, 1.0);


	gl_Position = projection * view * instanceData.model * vec4(aPos * size_amplification + offset, 1.0);
}
