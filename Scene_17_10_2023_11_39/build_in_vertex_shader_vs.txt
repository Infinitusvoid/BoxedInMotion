#version 330 core
layout (location = 0) in vec3 aPos;

// Define the instance data struct
struct Instance_data
{
	mat4 model;
	vec4 color;
};

layout(location = 3) in Instance_data instanceData;

out vec4 Color;
out vec3 FragWorldPos; // World space position
out vec3 FragObjectPos; // Object space position

uniform mat4 projection;
uniform mat4 view;

uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;

// #################################


// Defines constants ======================

#define PI 3.14159265359
#define TAO ( PI * 2.0 )

// ========================================

// ====================
// Utils functionality

// cosine based palette, 4 vec3 params
vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

// Define a function to generate a random number based on an input integer
float generateRandomNumber(int inputInt)
{
    // Cast the input integer to uint to address type mismatch
    uint seed = uint(inputInt);

    // Define the hash function
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);

    // Normalize and return the result
    return float(seed) / 4294967296.0; // Normalize to [0, 1]
}

vec3 calculate_index(vec3 p, vec3 spacing)
{
    return  vec3(round(p.x / spacing.x), round(p.y / spacing.y), round(p.z / spacing.z));
}

// ====================



// Function to compute the offset for the sphere
vec3 computeSphereOffset(float latitude, float longitude, float radius)
{
    float theta = 2.0 * 3.14159265359 * latitude;
    float phi = 2.0 * 3.14159265359 * longitude;

    float x = radius * sin(theta) * cos(phi);
    float y = radius * cos(theta);
    float z = radius * sin(theta) * sin(phi);

    return vec3(x, y, z);
}

vec3 parametricCube(float u, float v, float sideLength) {
    // Map u and v values to the range [0, 1]
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);

    // Calculate the cube's position in 3D space
    float x = mix(-sideLength, sideLength, u); // Varies from -sideLength to sideLength
    float y = mix(-sideLength, sideLength, v); // Varies from -sideLength to sideLength
    float z = sideLength; // Fixed z value to create a surface

    return vec3(x, y, z);
}

vec3 parametricCubeSide(float u, float v, float sideLength, int face) {
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);

    float halfLength = sideLength / 2.0;

    // Initialize position
    vec3 position = vec3(0.0);

    if (face == 0) {  // Front face
        position = vec3(u * sideLength - halfLength, v * sideLength - halfLength, halfLength);
    } else if (face == 1) {  // Back face
        position = vec3(halfLength - u * sideLength, v * sideLength - halfLength, -halfLength);
    } else if (face == 2) {  // Top face
        position = vec3(u * sideLength - halfLength, halfLength, v * sideLength - halfLength);
    } else if (face == 3) {  // Bottom face
        position = vec3(u * sideLength - halfLength, -halfLength, v * sideLength - halfLength);
    } else if (face == 4) {  // Right face
        position = vec3(halfLength, u * sideLength - halfLength, v * sideLength - halfLength);
    } else if (face == 5) {  // Left face
        position = vec3(-halfLength, halfLength - u * sideLength, v * sideLength - halfLength);
    }

    return position;
}

vec3 parametricCubeFull(float u, float v, float sideLength)
{
    vec3 position = vec3(0.0);
    if(u < ((1.0 / 3.0) * 1.0) )
    {
        if(v < 0.5)
        {
            position = parametricCubeSide(u * 3.0, v * 2.0, 1000.0, 0);
        }
        else
        {
            position = parametricCubeSide(u * 3.0, (v-0.5) * 2.0, 1000.0, 1);
        }
    }
    else if(u < ((1.0 / 3.0) * 2.0) )
    {
        if(v < 0.5)
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 1.0)) * 3.0 , v * 2.0, 1000.0, 2);
        }
        else
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 1.0)) * 3.0, (v-0.5) * 2.0, 1000.0, 3);
        }
    }
    else
    {
         if(v < 0.5)
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 2.0)) * 3.0, v * 2.0, 1000.0, 4);
        }
        else
        {
            position = parametricCubeSide((u - ((1.0 / 3.0) * 2.0)) * 3.0, (v-0.5) * 2.0, 1000.0, 5);
        }
    }

    return position;
}

vec3 calculate_instance_position(vec3 offset)
{
    return (instanceData.model * vec4(aPos + offset, 1.0)).xyz;
}

float waveform_0_f1(float x)
{
    return max(min(x*(5.0), 1.0),0.0);
}

float waveform_0_f2(float x)
{
    return max(min(-(x*5.0)+1.0 + 4.0, 1.0), 0.0);    
}

float waveform_0_f3(float x)
{
    
    return waveform_0_f1(x) * waveform_0_f2(x);
}

float waveform_0_f4(float x, float t)
{
    return pow(waveform_0_f3(x),  2 + (0.34 + 0.76 * sin(t + x*10000)))  * (0.99 + 0.01 * sin(x * 100 + t));
}

void main()
{
	int id = gl_InstanceID;
	FragObjectPos = aPos; // Store the object space position
	FragWorldPos = vec3(instanceData.model * vec4(aPos, 1.0)); // Calculate world space position
	Color = instanceData.color;


    // u, v
    // float u = float(id % 1000) * 0.001;
	// float v = float(id / 1000) * 0.001;
	


    
   
    // looping space for instances
    
    // UV created at rnd position
    float u = generateRandomNumber(id * 10023);
    float v = generateRandomNumber(id * 21823);

    // UV update
    {
        float particles_speed_factor = 0.01;
        float u_speed = (generateRandomNumber(id * 10033) - 0.5) * particles_speed_factor;
        float v_speed = (generateRandomNumber(id * 12334) - 0.5) * particles_speed_factor;

        // UV update position
        u += u_speed * time;
        v += v_speed * time;
    
        // UV looping space 0 to 1
        u = fract(u);
        v = fract(v);
    }

    
    

    float vertical_offset = 0.0;
    
    // base terrain
    {
        // parameters
        const float base_terrain_exponent = 0.5;
        const vec3 base_terrain_attractor_position = vec3(0.5, 0, 0.0);

        // calculations
        float distance_to_attractor = length(vec3(u, 0, v) - base_terrain_attractor_position);
        vertical_offset = pow(distance_to_attractor, base_terrain_exponent);
    }
    
    // terrain wave layer 0
    {
        {
            // parameters
            const float amplitude_0 =  0.0010;
            const float frequency_0 = 10;
            const float time_f_0 = 0.0;

            // calculations
            vertical_offset += amplitude_0 * sin(u * (PI * 2) * frequency_0 + time * time_f_0);
        }
        

        {
            // parameters
            const float amplitude_1 = -0.0002;
            const float frequency_1 =  2;
            const float time_f_1 = 0.0;

            // calculations
            vertical_offset += amplitude_1 * sin(u * (PI * 2) * frequency_1 + time * time_f_1);
        }
        
    }
    

    // layer 1 tiles

    // coordinate system tiles
    float x_global = u + time * 0.01;
    float y_global = v + time * 0.01;

    const vec3 spacing = vec3(0.04, 0.04, 0.04);
    const vec3 spacing_half = spacing * 0.5;
    const vec3 spacinging_reversed = vec3(1.0 / spacing.x, 1.0 / spacing.y, 1.0 / spacing.z);

    vec3 tile_coord = vec3(x_global / spacing.x, vertical_offset / spacing.y, y_global / spacing.z);
    vec3 tile_local_coord = fract((vec3(x_global, vertical_offset, y_global) + spacing_half ) * spacinging_reversed);

    vec3 tile_index = vec3(round(tile_coord.x), round(tile_coord.y), round(tile_coord.z)); // calculate_index(vec3(x_global, vertical_offset, y_global), spacing);
    int ixz = int(tile_index.x + tile_index.z);
    int ixz2 = int(tile_index.x * tile_index.z) % 999999;



    // random values    
    float tile_rnd_1 = generateRandomNumber( ixz + 176043);
    float tile_rnd_2 = generateRandomNumber( ixz + 538819);
    float tile_rnd_3 = generateRandomNumber( ixz + 558013);
    float tile_rnd_wave = generateRandomNumber( ixz + 762774);
    float tile_rnd_building = generateRandomNumber( ixz2 + 45447);
    
    //vec3 tile_rnd_color = vec3(tile_rnd_1, tile_rnd_2, tile_rnd_3);
    vec3 tile_rnd_color = vec3(tile_rnd_1, tile_rnd_2 , tile_rnd_3);
    
    
    float tile_x = tile_index.x;
    float tile_y = tile_index.z;
    float tile_off_v = 0.001 * sin(tile_coord.x * PI * 2.0 * 4 * tile_rnd_3 + time * 0.0) + 0.0002 * cos(tile_coord.y * PI * 2.0 * 4 * tile_rnd_wave + time * 0.0);
    
    if(tile_rnd_building > 0.5)
    {
        tile_off_v *= 0;
        tile_off_v += min(waveform_0_f4(tile_local_coord.z, time * 0.01), waveform_0_f4(tile_local_coord.x, time * 0.001)) * 0.01;
    }

    
    vertical_offset += tile_off_v;

    float tile_rnd_4 = generateRandomNumber(id * 762774);

    vec3 offset = vec3(0.0, 0.0, 0.0);
    offset = vec3(u, vertical_offset, v) * 10000;

    
   vec3 cube_position = calculate_instance_position(offset);
   vec3 v_cam = cube_position - camera_position;
   float d = length(v_cam);
    
   float factor_color_amplification = 1.0;
   if(d < 10)
   {
        factor_color_amplification *= 10;
   }

   
   
   float size_amplification = 1.0;
   if(d < 1)
   {
     size_amplification = 1.0 + (100.0 - (d+1.0)) * 0.1 ;
     //offset += vec3(0.0, -100.0, 0.0);
   }
    

    vec3 color = vec3(1.0, 1.0, 1.0);
    color *= tile_rnd_color;
    




    color *= factor_color_amplification;

	//Color = vec4(0.2 * v_cam.x, 0.4 * v_cam.y, 0.2 * v_cam.z, 1.0) + vec4(0.0, 0.0, 0.0, 1.0) * factor_color_amplification;
    Color = vec4(color, 1.0);


	gl_Position = projection * view * instanceData.model * vec4(aPos * size_amplification + offset, 1.0);
}
