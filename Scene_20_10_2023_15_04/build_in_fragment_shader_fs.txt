#version 330 core
layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 BrightColor;
in vec4 Color;
in vec3 FragWorldPos; // Input world space position
in vec3 FragObjectPos; // Input object space position


uniform vec3 camera_position;
uniform vec3 camera_front;
uniform vec3 camera_right;
uniform vec3 camera_up;
uniform float camera_zoom;
uniform int frame;
uniform float time;

// additional inputs
flat in int msg_frag_id;
in vec3 msg_frag_instance_position;

// ======================
// Defines constants 

#define PI 3.14159265359
#define TAO ( PI * 2.0 )
#define PI_2 ( PI * 2.0 )

#define SQRT_OF_2 1.4142135623730951

// ========================================
// Utils
// Define a function to generate a random number based on an input integer
float generateRandomNumber(int inputInt)
{
    // Cast the input integer to uint to address type mismatch
    uint seed = uint(inputInt);

    // Define the hash function
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);

    // Normalize and return the result
    return float(seed) / 4294967296.0; // Normalize to [0, 1]
}

float distance_from_sphere(in vec3 p, in vec3 c, in float r)
{
    return length(p - c) - r;
}

float map_the_world(in vec3 p)
{
    float displacement_influence = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;
    float sphere_0 = distance_from_sphere(p, vec3(0.0), 1.0);

    return sphere_0 + displacement_influence;
}

vec3 calculate_normal(in vec3 p)
{
    const vec3 small_step = vec3(0.001, 0.0, 0.0);

    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);
    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);
    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);

    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

    return normalize(normal);
}

vec3 ray_march(vec3 ro, vec3 rd)
{
    float total_distance_traveled = 0.0;
    const int NUMBER_OF_STEPS = 32;
    const float MINIMUM_HIT_DISTANCE = 0.001;
    const float MAXIMUM_TRACE_DISTANCE = 1000.0;
    
    for(int i = 0; i < NUMBER_OF_STEPS; i++)
    {
        // calculate our current position along the ray
        vec3 current_position = ro + total_distance_traveled * rd;
        
        //
        float distance_to_the_closest = distance_from_sphere(current_position, vec3(0.0), 1.0);
        
        if(distance_to_the_closest < MINIMUM_HIT_DISTANCE) // hit
        {
            vec3 normal = calculate_normal(current_position);
            
            // For now, hard-code the light's position in our scene
            vec3 light_position = vec3(2.0, -5.0, 3.0);
            
            // Calculate the unit direction vector that points from
            // the point of intersection to the light source
            vec3 direction_to_light = normalize(current_position - light_position);
            float diffuse_intensity = max(0.0, dot(normal, direction_to_light)) + 0.01;

            return vec3(0.0, 1.0, 0.0) * diffuse_intensity;
        }
        
        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE) // miss
        {
            break;
        }
        
        // accumulate the distance traveled thus far
        total_distance_traveled += distance_to_the_closest;
    }

    return vec3(0.0);
}

void main()
{
    int id = msg_frag_id;
    
    vec3 color = vec3(1.0, 1.0, 1.0);
    
    

    color.r = abs(sin(FragWorldPos.x * PI_2 * 10 + time + 1000.0 * generateRandomNumber(id)));
    color.g = abs(sin(FragWorldPos.y * PI_2 * 10 + time + 1000.0 * generateRandomNumber(id)));
    color.b = abs(sin(FragWorldPos.z * PI_2 * 10 + time + 1000.0 * generateRandomNumber(id)));
    
    color.r = 0.0;
    
    if(false)
    {
        vec2 v = vec2(FragObjectPos.x, FragObjectPos.y);
        color.g = abs(sin(FragObjectPos.x * PI_2 * 2.0));
        color.g = length(v);
        color.b = 0.0;
        
        if(msg_frag_instance_position.x < FragWorldPos.x +  0.24 * sin(FragWorldPos.y + time))
        {
            color *= 0.24;
        }
    }
    
    // Virtual
    vec3 virtual_camera_position = vec3(sin(time), sin(time) * 0.0, 2.0 + 0.5 * sin(time));
    vec3 virtual_direction = normalize(virtual_camera_position - FragObjectPos);
    
    virtual_camera_position = vec3(0.0, 0.0, -7.0);
    virtual_direction = vec3(FragObjectPos.x * 2 - 1.0, FragObjectPos.y * 2.0 - 1.0, 1.0);
    
    //virtual_direction = normalize((FragObjectPos - camera_position) - FragObjectPos);

    virtual_camera_position = camera_position - msg_frag_instance_position;
    virtual_direction = normalize(FragWorldPos - camera_position);

    //virtual_camera_position = camera_position - msg_frag_instance_position;

    //virtual_direction = camera_position - vec3(FragObjectPos.x * 2 - 1.0, FragObjectPos.y * 2.0 - 1.0, 1.0);

    
    color = ray_march(virtual_camera_position, virtual_direction);
   
   
   if(false)
   {
        color += vec3(msg_frag_instance_position.x, msg_frag_instance_position.y, msg_frag_instance_position.z) * 0.01;
        
        if(msg_frag_instance_position.x < FragWorldPos.x)
        {
            color *= 10;
        }
    }
   

    //
    
    vec4 result = Color * 0.0+ vec4(color, 1.0);
    
    FragColor = result * 1.0;
    float factor_brightnes = dot(vec3(result), vec3(0.2126, 0.7152, 0.0722));
    if(factor_brightnes > 1.0) // transhold usually set at 1.0
    {
        BrightColor = vec4(result.x * 10.0, result.y * 10.0, result.z * 10.0, 1.0);
    }
    else
    {
        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
    
}
